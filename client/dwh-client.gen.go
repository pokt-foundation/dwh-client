// Package client provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.15.0 DO NOT EDIT.
package client

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	ApiKeyScopes = "apiKey.Scopes"
)

// Defines values for GetAnalyticsRelaysAggregatedCategoryParamsCategory.
const (
	GetAnalyticsRelaysAggregatedCategoryParamsCategoryAccountId     GetAnalyticsRelaysAggregatedCategoryParamsCategory = "account_id"
	GetAnalyticsRelaysAggregatedCategoryParamsCategoryApplicationId GetAnalyticsRelaysAggregatedCategoryParamsCategory = "application_id"
)

// Defines values for GetAnalyticsRelaysTotalCategoryParamsCategory.
const (
	GetAnalyticsRelaysTotalCategoryParamsCategoryAccountId     GetAnalyticsRelaysTotalCategoryParamsCategory = "account_id"
	GetAnalyticsRelaysTotalCategoryParamsCategoryApplicationId GetAnalyticsRelaysTotalCategoryParamsCategory = "application_id"
)

// Defines values for GetAnalyticsRelaysCategoryParamsCategory.
const (
	Errors       GetAnalyticsRelaysCategoryParamsCategory = "errors"
	Transactions GetAnalyticsRelaysCategoryParamsCategory = "transactions"
)

// AnalyticsRelaysAggregated defines model for AnalyticsRelaysAggregated.
type AnalyticsRelaysAggregated struct {
	AvgLatency    *float32            `json:"avg_latency,omitempty"`
	CategoryValue *string             `json:"category_value,omitempty"`
	CountTotal    *int                `json:"count_total,omitempty"`
	Date          *openapi_types.Date `json:"date,omitempty"`
	RateError     *float32            `json:"rate_error,omitempty"`
	RateSuccess   *float32            `json:"rate_success,omitempty"`
}

// AnalyticsRelaysErrors defines model for AnalyticsRelaysErrors.
type AnalyticsRelaysErrors struct {
	AccountId           *string             `json:"account_id,omitempty"`
	ChainId             *string             `json:"chain_id,omitempty"`
	ChainMethod         *string             `json:"chain_method,omitempty"`
	Cnt                 *int                `json:"cnt,omitempty"`
	ErrorName           *string             `json:"error_name,omitempty"`
	ErrorType           *string             `json:"error_type,omitempty"`
	From                *openapi_types.Date `json:"from,omitempty"`
	PortalApplicationId *string             `json:"portal_application_id,omitempty"`
	To                  *openapi_types.Date `json:"to,omitempty"`
}

// AnalyticsRelaysTotal defines model for AnalyticsRelaysTotal.
type AnalyticsRelaysTotal struct {
	AvgLatency    *float32            `json:"avg_latency,omitempty"`
	CategoryValue *string             `json:"category_value,omitempty"`
	CountTotal    *int                `json:"count_total,omitempty"`
	From          *openapi_types.Date `json:"from,omitempty"`
	RateError     *float32            `json:"rate_error,omitempty"`
	RateSuccess   *float32            `json:"rate_success,omitempty"`
	To            *openapi_types.Date `json:"to,omitempty"`
}

// AnalyticsRelaysTransactions defines model for AnalyticsRelaysTransactions.
type AnalyticsRelaysTransactions struct {
	AccountId           *string             `json:"account_id,omitempty"`
	AvgRoundtripTime    *float32            `json:"avg_roundtrip_time,omitempty"`
	ChainId             *string             `json:"chain_id,omitempty"`
	ChainMethod         *string             `json:"chain_method,omitempty"`
	Cnt                 *int                `json:"cnt,omitempty"`
	ErrorRate           *float32            `json:"error_rate,omitempty"`
	From                *openapi_types.Date `json:"from,omitempty"`
	PortalApplicationId *string             `json:"portal_application_id,omitempty"`
	To                  *openapi_types.Date `json:"to,omitempty"`
}

// Error defines model for Error.
type Error struct {
	Code    *int    `json:"code,omitempty"`
	Message *string `json:"message,omitempty"`
}

// Logs defines model for Logs.
type Logs struct {
	ChainId             *string `json:"chain_id,omitempty"`
	ChainMethod         *string `json:"chain_method,omitempty"`
	ErrorMessage        *string `json:"error_message,omitempty"`
	ErrorName           *string `json:"error_name,omitempty"`
	ErrorType           *string `json:"error_type,omitempty"`
	PortalApplicationId *string `json:"portal_application_id,omitempty"`
	Ts                  *string `json:"ts,omitempty"`
}

// Response defines model for Response.
type Response struct {
	Data *[]Response_Data_Item `json:"data,omitempty"`
}

// Response_Data_Item defines model for Response.data.Item.
type Response_Data_Item struct {
	union json.RawMessage
}

// NotFound defines model for NotFound.
type NotFound = Error

// Unauthorized defines model for Unauthorized.
type Unauthorized = Error

// GetAnalyticsRelaysAggregatedCategoryParams defines parameters for GetAnalyticsRelaysAggregatedCategory.
type GetAnalyticsRelaysAggregatedCategoryParams struct {
	From          openapi_types.Date `form:"from" json:"from"`
	To            openapi_types.Date `form:"to" json:"to"`
	CategoryValue []string           `form:"category_value" json:"category_value"`
}

// GetAnalyticsRelaysAggregatedCategoryParamsCategory defines parameters for GetAnalyticsRelaysAggregatedCategory.
type GetAnalyticsRelaysAggregatedCategoryParamsCategory string

// GetAnalyticsRelaysTotalCategoryParams defines parameters for GetAnalyticsRelaysTotalCategory.
type GetAnalyticsRelaysTotalCategoryParams struct {
	From          openapi_types.Date `form:"from" json:"from"`
	To            openapi_types.Date `form:"to" json:"to"`
	CategoryValue []string           `form:"category_value" json:"category_value"`
}

// GetAnalyticsRelaysTotalCategoryParamsCategory defines parameters for GetAnalyticsRelaysTotalCategory.
type GetAnalyticsRelaysTotalCategoryParamsCategory string

// GetAnalyticsRelaysCategoryParams defines parameters for GetAnalyticsRelaysCategory.
type GetAnalyticsRelaysCategoryParams struct {
	From                openapi_types.Date `form:"from" json:"from"`
	To                  openapi_types.Date `form:"to" json:"to"`
	AccountId           []string           `form:"account_id" json:"account_id"`
	PortalApplicationId *[]string          `form:"portal_application_id,omitempty" json:"portal_application_id,omitempty"`
	ChainId             *[]string          `form:"chain_id,omitempty" json:"chain_id,omitempty"`
	ChainMethod         *[]string          `form:"chain_method,omitempty" json:"chain_method,omitempty"`
}

// GetAnalyticsRelaysCategoryParamsCategory defines parameters for GetAnalyticsRelaysCategory.
type GetAnalyticsRelaysCategoryParamsCategory string

// GetLogsParams defines parameters for GetLogs.
type GetLogsParams struct {
	PortalApplicationId []string `form:"portal_application_id" json:"portal_application_id"`
}

// AsAnalyticsRelaysAggregated returns the union data inside the Response_Data_Item as a AnalyticsRelaysAggregated
func (t Response_Data_Item) AsAnalyticsRelaysAggregated() (AnalyticsRelaysAggregated, error) {
	var body AnalyticsRelaysAggregated
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAnalyticsRelaysAggregated overwrites any union data inside the Response_Data_Item as the provided AnalyticsRelaysAggregated
func (t *Response_Data_Item) FromAnalyticsRelaysAggregated(v AnalyticsRelaysAggregated) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAnalyticsRelaysAggregated performs a merge with any union data inside the Response_Data_Item, using the provided AnalyticsRelaysAggregated
func (t *Response_Data_Item) MergeAnalyticsRelaysAggregated(v AnalyticsRelaysAggregated) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsAnalyticsRelaysTotal returns the union data inside the Response_Data_Item as a AnalyticsRelaysTotal
func (t Response_Data_Item) AsAnalyticsRelaysTotal() (AnalyticsRelaysTotal, error) {
	var body AnalyticsRelaysTotal
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAnalyticsRelaysTotal overwrites any union data inside the Response_Data_Item as the provided AnalyticsRelaysTotal
func (t *Response_Data_Item) FromAnalyticsRelaysTotal(v AnalyticsRelaysTotal) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAnalyticsRelaysTotal performs a merge with any union data inside the Response_Data_Item, using the provided AnalyticsRelaysTotal
func (t *Response_Data_Item) MergeAnalyticsRelaysTotal(v AnalyticsRelaysTotal) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsAnalyticsRelaysTransactions returns the union data inside the Response_Data_Item as a AnalyticsRelaysTransactions
func (t Response_Data_Item) AsAnalyticsRelaysTransactions() (AnalyticsRelaysTransactions, error) {
	var body AnalyticsRelaysTransactions
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAnalyticsRelaysTransactions overwrites any union data inside the Response_Data_Item as the provided AnalyticsRelaysTransactions
func (t *Response_Data_Item) FromAnalyticsRelaysTransactions(v AnalyticsRelaysTransactions) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAnalyticsRelaysTransactions performs a merge with any union data inside the Response_Data_Item, using the provided AnalyticsRelaysTransactions
func (t *Response_Data_Item) MergeAnalyticsRelaysTransactions(v AnalyticsRelaysTransactions) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsAnalyticsRelaysErrors returns the union data inside the Response_Data_Item as a AnalyticsRelaysErrors
func (t Response_Data_Item) AsAnalyticsRelaysErrors() (AnalyticsRelaysErrors, error) {
	var body AnalyticsRelaysErrors
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAnalyticsRelaysErrors overwrites any union data inside the Response_Data_Item as the provided AnalyticsRelaysErrors
func (t *Response_Data_Item) FromAnalyticsRelaysErrors(v AnalyticsRelaysErrors) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAnalyticsRelaysErrors performs a merge with any union data inside the Response_Data_Item, using the provided AnalyticsRelaysErrors
func (t *Response_Data_Item) MergeAnalyticsRelaysErrors(v AnalyticsRelaysErrors) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsLogs returns the union data inside the Response_Data_Item as a Logs
func (t Response_Data_Item) AsLogs() (Logs, error) {
	var body Logs
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromLogs overwrites any union data inside the Response_Data_Item as the provided Logs
func (t *Response_Data_Item) FromLogs(v Logs) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeLogs performs a merge with any union data inside the Response_Data_Item, using the provided Logs
func (t *Response_Data_Item) MergeLogs(v Logs) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t Response_Data_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Response_Data_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetAnalyticsRelaysAggregatedCategory request
	GetAnalyticsRelaysAggregatedCategory(ctx context.Context, category GetAnalyticsRelaysAggregatedCategoryParamsCategory, params *GetAnalyticsRelaysAggregatedCategoryParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAnalyticsRelaysTotalCategory request
	GetAnalyticsRelaysTotalCategory(ctx context.Context, category GetAnalyticsRelaysTotalCategoryParamsCategory, params *GetAnalyticsRelaysTotalCategoryParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAnalyticsRelaysCategory request
	GetAnalyticsRelaysCategory(ctx context.Context, category GetAnalyticsRelaysCategoryParamsCategory, params *GetAnalyticsRelaysCategoryParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetHealthcheck request
	GetHealthcheck(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLogs request
	GetLogs(ctx context.Context, params *GetLogsParams, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetAnalyticsRelaysAggregatedCategory(ctx context.Context, category GetAnalyticsRelaysAggregatedCategoryParamsCategory, params *GetAnalyticsRelaysAggregatedCategoryParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAnalyticsRelaysAggregatedCategoryRequest(c.Server, category, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAnalyticsRelaysTotalCategory(ctx context.Context, category GetAnalyticsRelaysTotalCategoryParamsCategory, params *GetAnalyticsRelaysTotalCategoryParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAnalyticsRelaysTotalCategoryRequest(c.Server, category, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAnalyticsRelaysCategory(ctx context.Context, category GetAnalyticsRelaysCategoryParamsCategory, params *GetAnalyticsRelaysCategoryParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAnalyticsRelaysCategoryRequest(c.Server, category, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetHealthcheck(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetHealthcheckRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLogs(ctx context.Context, params *GetLogsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLogsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetAnalyticsRelaysAggregatedCategoryRequest generates requests for GetAnalyticsRelaysAggregatedCategory
func NewGetAnalyticsRelaysAggregatedCategoryRequest(server string, category GetAnalyticsRelaysAggregatedCategoryParamsCategory, params *GetAnalyticsRelaysAggregatedCategoryParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "category", runtime.ParamLocationPath, category)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/analytics/relays/aggregated/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "from", runtime.ParamLocationQuery, params.From); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "to", runtime.ParamLocationQuery, params.To); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "category_value", runtime.ParamLocationQuery, params.CategoryValue); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAnalyticsRelaysTotalCategoryRequest generates requests for GetAnalyticsRelaysTotalCategory
func NewGetAnalyticsRelaysTotalCategoryRequest(server string, category GetAnalyticsRelaysTotalCategoryParamsCategory, params *GetAnalyticsRelaysTotalCategoryParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "category", runtime.ParamLocationPath, category)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/analytics/relays/total/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "from", runtime.ParamLocationQuery, params.From); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "to", runtime.ParamLocationQuery, params.To); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "category_value", runtime.ParamLocationQuery, params.CategoryValue); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAnalyticsRelaysCategoryRequest generates requests for GetAnalyticsRelaysCategory
func NewGetAnalyticsRelaysCategoryRequest(server string, category GetAnalyticsRelaysCategoryParamsCategory, params *GetAnalyticsRelaysCategoryParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "category", runtime.ParamLocationPath, category)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/analytics/relays/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "from", runtime.ParamLocationQuery, params.From); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "to", runtime.ParamLocationQuery, params.To); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "account_id", runtime.ParamLocationQuery, params.AccountId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.PortalApplicationId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "portal_application_id", runtime.ParamLocationQuery, *params.PortalApplicationId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ChainId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "chain_id", runtime.ParamLocationQuery, *params.ChainId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ChainMethod != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "chain_method", runtime.ParamLocationQuery, *params.ChainMethod); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetHealthcheckRequest generates requests for GetHealthcheck
func NewGetHealthcheckRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/healthcheck")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLogsRequest generates requests for GetLogs
func NewGetLogsRequest(server string, params *GetLogsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/logs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "portal_application_id", runtime.ParamLocationQuery, params.PortalApplicationId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetAnalyticsRelaysAggregatedCategoryWithResponse request
	GetAnalyticsRelaysAggregatedCategoryWithResponse(ctx context.Context, category GetAnalyticsRelaysAggregatedCategoryParamsCategory, params *GetAnalyticsRelaysAggregatedCategoryParams, reqEditors ...RequestEditorFn) (*GetAnalyticsRelaysAggregatedCategoryResponse, error)

	// GetAnalyticsRelaysTotalCategoryWithResponse request
	GetAnalyticsRelaysTotalCategoryWithResponse(ctx context.Context, category GetAnalyticsRelaysTotalCategoryParamsCategory, params *GetAnalyticsRelaysTotalCategoryParams, reqEditors ...RequestEditorFn) (*GetAnalyticsRelaysTotalCategoryResponse, error)

	// GetAnalyticsRelaysCategoryWithResponse request
	GetAnalyticsRelaysCategoryWithResponse(ctx context.Context, category GetAnalyticsRelaysCategoryParamsCategory, params *GetAnalyticsRelaysCategoryParams, reqEditors ...RequestEditorFn) (*GetAnalyticsRelaysCategoryResponse, error)

	// GetHealthcheckWithResponse request
	GetHealthcheckWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetHealthcheckResponse, error)

	// GetLogsWithResponse request
	GetLogsWithResponse(ctx context.Context, params *GetLogsParams, reqEditors ...RequestEditorFn) (*GetLogsResponse, error)
}

type GetAnalyticsRelaysAggregatedCategoryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Response
	JSON204      *Error
	JSON401      *Unauthorized
	JSON404      *NotFound
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetAnalyticsRelaysAggregatedCategoryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAnalyticsRelaysAggregatedCategoryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAnalyticsRelaysTotalCategoryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Response
	JSON204      *Error
	JSON401      *Unauthorized
	JSON404      *NotFound
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetAnalyticsRelaysTotalCategoryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAnalyticsRelaysTotalCategoryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAnalyticsRelaysCategoryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Response
	JSON204      *Error
	JSON401      *Unauthorized
	JSON404      *NotFound
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetAnalyticsRelaysCategoryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAnalyticsRelaysCategoryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetHealthcheckResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetHealthcheckResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetHealthcheckResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLogsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Response
	JSON204      *Error
	JSON401      *Unauthorized
	JSON404      *NotFound
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetLogsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLogsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetAnalyticsRelaysAggregatedCategoryWithResponse request returning *GetAnalyticsRelaysAggregatedCategoryResponse
func (c *ClientWithResponses) GetAnalyticsRelaysAggregatedCategoryWithResponse(ctx context.Context, category GetAnalyticsRelaysAggregatedCategoryParamsCategory, params *GetAnalyticsRelaysAggregatedCategoryParams, reqEditors ...RequestEditorFn) (*GetAnalyticsRelaysAggregatedCategoryResponse, error) {
	rsp, err := c.GetAnalyticsRelaysAggregatedCategory(ctx, category, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAnalyticsRelaysAggregatedCategoryResponse(rsp)
}

// GetAnalyticsRelaysTotalCategoryWithResponse request returning *GetAnalyticsRelaysTotalCategoryResponse
func (c *ClientWithResponses) GetAnalyticsRelaysTotalCategoryWithResponse(ctx context.Context, category GetAnalyticsRelaysTotalCategoryParamsCategory, params *GetAnalyticsRelaysTotalCategoryParams, reqEditors ...RequestEditorFn) (*GetAnalyticsRelaysTotalCategoryResponse, error) {
	rsp, err := c.GetAnalyticsRelaysTotalCategory(ctx, category, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAnalyticsRelaysTotalCategoryResponse(rsp)
}

// GetAnalyticsRelaysCategoryWithResponse request returning *GetAnalyticsRelaysCategoryResponse
func (c *ClientWithResponses) GetAnalyticsRelaysCategoryWithResponse(ctx context.Context, category GetAnalyticsRelaysCategoryParamsCategory, params *GetAnalyticsRelaysCategoryParams, reqEditors ...RequestEditorFn) (*GetAnalyticsRelaysCategoryResponse, error) {
	rsp, err := c.GetAnalyticsRelaysCategory(ctx, category, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAnalyticsRelaysCategoryResponse(rsp)
}

// GetHealthcheckWithResponse request returning *GetHealthcheckResponse
func (c *ClientWithResponses) GetHealthcheckWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetHealthcheckResponse, error) {
	rsp, err := c.GetHealthcheck(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetHealthcheckResponse(rsp)
}

// GetLogsWithResponse request returning *GetLogsResponse
func (c *ClientWithResponses) GetLogsWithResponse(ctx context.Context, params *GetLogsParams, reqEditors ...RequestEditorFn) (*GetLogsResponse, error) {
	rsp, err := c.GetLogs(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLogsResponse(rsp)
}

// ParseGetAnalyticsRelaysAggregatedCategoryResponse parses an HTTP response from a GetAnalyticsRelaysAggregatedCategoryWithResponse call
func ParseGetAnalyticsRelaysAggregatedCategoryResponse(rsp *http.Response) (*GetAnalyticsRelaysAggregatedCategoryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAnalyticsRelaysAggregatedCategoryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 204:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON204 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAnalyticsRelaysTotalCategoryResponse parses an HTTP response from a GetAnalyticsRelaysTotalCategoryWithResponse call
func ParseGetAnalyticsRelaysTotalCategoryResponse(rsp *http.Response) (*GetAnalyticsRelaysTotalCategoryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAnalyticsRelaysTotalCategoryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 204:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON204 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAnalyticsRelaysCategoryResponse parses an HTTP response from a GetAnalyticsRelaysCategoryWithResponse call
func ParseGetAnalyticsRelaysCategoryResponse(rsp *http.Response) (*GetAnalyticsRelaysCategoryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAnalyticsRelaysCategoryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 204:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON204 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetHealthcheckResponse parses an HTTP response from a GetHealthcheckWithResponse call
func ParseGetHealthcheckResponse(rsp *http.Response) (*GetHealthcheckResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetHealthcheckResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetLogsResponse parses an HTTP response from a GetLogsWithResponse call
func ParseGetLogsResponse(rsp *http.Response) (*GetLogsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLogsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 204:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON204 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Relays analytics retrieve aggregated values of a chosen metric category between selected dates.
	// (GET /analytics/relays/aggregated/{category})
	GetAnalyticsRelaysAggregatedCategory(ctx echo.Context, category GetAnalyticsRelaysAggregatedCategoryParamsCategory, params GetAnalyticsRelaysAggregatedCategoryParams) error
	// Relays analytics retrieve aggregated values of a chosen metric category between selected dates.
	// (GET /analytics/relays/total/{category})
	GetAnalyticsRelaysTotalCategory(ctx echo.Context, category GetAnalyticsRelaysTotalCategoryParamsCategory, params GetAnalyticsRelaysTotalCategoryParams) error
	// Relays analytics retrieve aggregated values of a chosen metric category between selected dates.
	// (GET /analytics/relays/{category})
	GetAnalyticsRelaysCategory(ctx echo.Context, category GetAnalyticsRelaysCategoryParamsCategory, params GetAnalyticsRelaysCategoryParams) error
	// Check the health of the service.
	// (GET /healthcheck)
	GetHealthcheck(ctx echo.Context) error
	// Retrieve application error messages by given timestamp range.
	// (GET /logs)
	GetLogs(ctx echo.Context, params GetLogsParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// GetAnalyticsRelaysAggregatedCategory converts echo context to params.
func (w *ServerInterfaceWrapper) GetAnalyticsRelaysAggregatedCategory(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "category" -------------
	var category GetAnalyticsRelaysAggregatedCategoryParamsCategory

	err = runtime.BindStyledParameterWithLocation("simple", false, "category", runtime.ParamLocationPath, ctx.Param("category"), &category)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter category: %s", err))
	}

	ctx.Set(ApiKeyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAnalyticsRelaysAggregatedCategoryParams
	// ------------- Required query parameter "from" -------------

	err = runtime.BindQueryParameter("form", true, true, "from", ctx.QueryParams(), &params.From)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter from: %s", err))
	}

	// ------------- Required query parameter "to" -------------

	err = runtime.BindQueryParameter("form", true, true, "to", ctx.QueryParams(), &params.To)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter to: %s", err))
	}

	// ------------- Required query parameter "category_value" -------------

	err = runtime.BindQueryParameter("form", true, true, "category_value", ctx.QueryParams(), &params.CategoryValue)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter category_value: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetAnalyticsRelaysAggregatedCategory(ctx, category, params)
	return err
}

// GetAnalyticsRelaysTotalCategory converts echo context to params.
func (w *ServerInterfaceWrapper) GetAnalyticsRelaysTotalCategory(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "category" -------------
	var category GetAnalyticsRelaysTotalCategoryParamsCategory

	err = runtime.BindStyledParameterWithLocation("simple", false, "category", runtime.ParamLocationPath, ctx.Param("category"), &category)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter category: %s", err))
	}

	ctx.Set(ApiKeyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAnalyticsRelaysTotalCategoryParams
	// ------------- Required query parameter "from" -------------

	err = runtime.BindQueryParameter("form", true, true, "from", ctx.QueryParams(), &params.From)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter from: %s", err))
	}

	// ------------- Required query parameter "to" -------------

	err = runtime.BindQueryParameter("form", true, true, "to", ctx.QueryParams(), &params.To)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter to: %s", err))
	}

	// ------------- Required query parameter "category_value" -------------

	err = runtime.BindQueryParameter("form", true, true, "category_value", ctx.QueryParams(), &params.CategoryValue)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter category_value: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetAnalyticsRelaysTotalCategory(ctx, category, params)
	return err
}

// GetAnalyticsRelaysCategory converts echo context to params.
func (w *ServerInterfaceWrapper) GetAnalyticsRelaysCategory(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "category" -------------
	var category GetAnalyticsRelaysCategoryParamsCategory

	err = runtime.BindStyledParameterWithLocation("simple", false, "category", runtime.ParamLocationPath, ctx.Param("category"), &category)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter category: %s", err))
	}

	ctx.Set(ApiKeyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAnalyticsRelaysCategoryParams
	// ------------- Required query parameter "from" -------------

	err = runtime.BindQueryParameter("form", true, true, "from", ctx.QueryParams(), &params.From)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter from: %s", err))
	}

	// ------------- Required query parameter "to" -------------

	err = runtime.BindQueryParameter("form", true, true, "to", ctx.QueryParams(), &params.To)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter to: %s", err))
	}

	// ------------- Required query parameter "account_id" -------------

	err = runtime.BindQueryParameter("form", true, true, "account_id", ctx.QueryParams(), &params.AccountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account_id: %s", err))
	}

	// ------------- Optional query parameter "portal_application_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "portal_application_id", ctx.QueryParams(), &params.PortalApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter portal_application_id: %s", err))
	}

	// ------------- Optional query parameter "chain_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "chain_id", ctx.QueryParams(), &params.ChainId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter chain_id: %s", err))
	}

	// ------------- Optional query parameter "chain_method" -------------

	err = runtime.BindQueryParameter("form", true, false, "chain_method", ctx.QueryParams(), &params.ChainMethod)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter chain_method: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetAnalyticsRelaysCategory(ctx, category, params)
	return err
}

// GetHealthcheck converts echo context to params.
func (w *ServerInterfaceWrapper) GetHealthcheck(ctx echo.Context) error {
	var err error

	ctx.Set(ApiKeyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetHealthcheck(ctx)
	return err
}

// GetLogs converts echo context to params.
func (w *ServerInterfaceWrapper) GetLogs(ctx echo.Context) error {
	var err error

	ctx.Set(ApiKeyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLogsParams
	// ------------- Required query parameter "portal_application_id" -------------

	err = runtime.BindQueryParameter("form", true, true, "portal_application_id", ctx.QueryParams(), &params.PortalApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter portal_application_id: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetLogs(ctx, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/analytics/relays/aggregated/:category", wrapper.GetAnalyticsRelaysAggregatedCategory)
	router.GET(baseURL+"/analytics/relays/total/:category", wrapper.GetAnalyticsRelaysTotalCategory)
	router.GET(baseURL+"/analytics/relays/:category", wrapper.GetAnalyticsRelaysCategory)
	router.GET(baseURL+"/healthcheck", wrapper.GetHealthcheck)
	router.GET(baseURL+"/logs", wrapper.GetLogs)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/+xYT2/buBP9KgR/v6NsuWn24luQZjdBi6RIuughMAyGGkvsSqRKjpz1Bv7uiyElW7bl",
	"xEmcblH4ZoucP3x888jhA5emKI0GjY4PH7gFVxrtwP+5NPi7qXRCv6XRCBrppyjLXEmByuj4mzOavjmZ",
	"QSHo1/8tTPiQ/y9eOo7DqIvPrDWWz+fziCfgpFUlOeFDfg3OVFYC0wbZxMecR/xPLSrMjFX/wA/IoR2N",
	"WfhegUNO02pLcnyiRT5DJd015GLmTtLUQiowpFdaU4JFFcAT03ScCwQtZ/R3YmwhkA/5JDcCecRxVgIf",
	"cl0Vd2BptVIgpMbOxlORV0A29RSHVunUTzGVxjEaFHlrXGmENPhIBMJKNP8h2vRkBcIYPBQ7Jefnu0pK",
	"cG4Xi/nii7n7BhLJxxp4fiNcB3AyLFMl3RhkQunHBwvAzGyZEOiziZzHYqxF0Y18GA6fO4Yn1hQ74V4a",
	"iyIft+i7bSlodnC4A8xfGrb8BPTcGaa3puce4bVCOyFpJ5/PZdoES2qHVpVjVAXsuBdvWQN2XUO2pvEz",
	"sf6sIcvqBkiTQPdiC3BOpF1E7nL/yaQd2/u6fQhwb8/jtaL0DNRXi4aI6FAU5W7QX9d3hk18EoH+PFYI",
	"hf9gNFxN+PD28SN6+yk7j55lGbTvuUbtin6mbX2mPWXl2TQfLcEU1opZF7p0/QBZWYWzGzKuZaVUH8Hr",
	"tqKbSwYiAcsjHpjCP/uN7334et67ATtVEnonpeqRyTJicOHvQUpPfNmt3odqU4aZQFZaM1UJOEZbyqjw",
	"2Yev5wwNwwxYCMgjnisJNRPqXE5KITNgR/0Bj3hlc0oXsXTDOL6/v+8LP9w3No1rWxd/ujg9u7w565EN",
	"IaIwX67Kh21SO/l8wSM+BetCyu+ChSlBi1LxIX/fH/jApcDMIxeLZsNi63csFgt2xQ/NGTenqSl4mSQ+",
	"++K5SPiQ/wG4lZ2ntbWPZ0UBCHS/ua136XsFfqwGxotnxOmiqSxdINFWELUusU+KYLdfNG/hde30fyzC",
	"otg3ZWaN7OuM+5IBawIxM2GCFYBWSaJZCsiUdirN0DEz6fMo5Ek7u5nmowmCrgo+vG0fzhFfU8nRJjKj",
	"aLU7OhoM9taULCS0oy+5+kjYHQ2O374FujSsCTCP+PHg3TZPCyDilR7NGx0/bbRoLH0GE1Hl+CP6O/i7",
	"BImQMKjnRNxVRSHszLegVM1soQ/MEvdgCmypEMyz3wVuysw40A1FF7y9A7wH0MxBHoJRoTniKwq6Q9zy",
	"yoHlI4q+qUb+8vwyIfKH3UGDDhp00KCDBr1Gg16kPr+K8PynaoDt1qPu71yXDmxZ/oqa7Ecdu8J0N5b7",
	"jLBorPfvtG7IX+T4IL8H+d23/GYgcsxkBvKvx+T2vDWtm4WbyuXqNlk5FqLM+gT3b4P3T87XBls2Kyid",
	"Ug6+7Q8TCApcWreX6WYOoagXmtdPaNtW6B9Fdjo9tunPHhTvUOG/eIU3Bb0MHSay+h3WsbsZS9UUNFs8",
	"gzIrdApd9dt6nvNsbR7mbkfEJKqIhsfh6SsWpYqn7ziN1r7WC/GqqQuSn9xLDhomStUL7pZlUFfX5q2l",
	"24XSiZqqpBI5CwXEaBUkdwnVr7JtUNwyjF/rrkFICGrv/qVQOCbYfWZyaJWvNUklkc9H838DAAD//821",
	"S39/HgAA",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
