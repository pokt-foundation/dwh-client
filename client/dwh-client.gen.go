// Package client provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen/v2 version v2.0.0 DO NOT EDIT.
package client

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	ApiKeyScopes = "apiKey.Scopes"
)

// Defines values for GetAnalyticsRelaysAggregatedCategoryParamsCategory.
const (
	GetAnalyticsRelaysAggregatedCategoryParamsCategoryAccountId     GetAnalyticsRelaysAggregatedCategoryParamsCategory = "account_id"
	GetAnalyticsRelaysAggregatedCategoryParamsCategoryApplicationId GetAnalyticsRelaysAggregatedCategoryParamsCategory = "application_id"
)

// Defines values for GetAnalyticsRelaysTotalCategoryParamsCategory.
const (
	GetAnalyticsRelaysTotalCategoryParamsCategoryAccountId     GetAnalyticsRelaysTotalCategoryParamsCategory = "account_id"
	GetAnalyticsRelaysTotalCategoryParamsCategoryApplicationId GetAnalyticsRelaysTotalCategoryParamsCategory = "application_id"
)

// Defines values for GetAnalyticsRelaysCategoryParamsCategory.
const (
	Errors       GetAnalyticsRelaysCategoryParamsCategory = "errors"
	Transactions GetAnalyticsRelaysCategoryParamsCategory = "transactions"
)

// AnalyticsRelaysAggregated defines model for AnalyticsRelaysAggregated.
type AnalyticsRelaysAggregated struct {
	AvgLatency    *float32            `json:"avg_latency,omitempty"`
	CategoryValue *string             `json:"category_value,omitempty"`
	CountTotal    *int                `json:"count_total,omitempty"`
	Date          *openapi_types.Date `json:"date,omitempty"`
	RateError     *float32            `json:"rate_error,omitempty"`
	RateSuccess   *float32            `json:"rate_success,omitempty"`
}

// AnalyticsRelaysErrors defines model for AnalyticsRelaysErrors.
type AnalyticsRelaysErrors struct {
	AccountId           *string             `json:"account_id,omitempty"`
	ChainId             *string             `json:"chain_id,omitempty"`
	ChainMethod         *string             `json:"chain_method,omitempty"`
	Cnt                 *int                `json:"cnt,omitempty"`
	ErrorName           *string             `json:"error_name,omitempty"`
	ErrorType           *string             `json:"error_type,omitempty"`
	From                *openapi_types.Date `json:"from,omitempty"`
	PortalApplicationId *string             `json:"portal_application_id,omitempty"`
	To                  *openapi_types.Date `json:"to,omitempty"`
}

// AnalyticsRelaysTotal defines model for AnalyticsRelaysTotal.
type AnalyticsRelaysTotal struct {
	AvgLatency    *float32            `json:"avg_latency,omitempty"`
	CategoryValue *string             `json:"category_value,omitempty"`
	CountTotal    *int                `json:"count_total,omitempty"`
	From          *openapi_types.Date `json:"from,omitempty"`
	RateError     *float32            `json:"rate_error,omitempty"`
	RateSuccess   *float32            `json:"rate_success,omitempty"`
	To            *openapi_types.Date `json:"to,omitempty"`
}

// AnalyticsRelaysTransactions defines model for AnalyticsRelaysTransactions.
type AnalyticsRelaysTransactions struct {
	AccountId           *string             `json:"account_id,omitempty"`
	AvgRoundtripTime    *float32            `json:"avg_roundtrip_time,omitempty"`
	ChainId             *string             `json:"chain_id,omitempty"`
	ChainMethod         *string             `json:"chain_method,omitempty"`
	Cnt                 *int                `json:"cnt,omitempty"`
	ErrorRate           *float32            `json:"error_rate,omitempty"`
	From                *openapi_types.Date `json:"from,omitempty"`
	PortalApplicationId *string             `json:"portal_application_id,omitempty"`
	To                  *openapi_types.Date `json:"to,omitempty"`
}

// Error defines model for Error.
type Error struct {
	Code    *int    `json:"code,omitempty"`
	Message *string `json:"message,omitempty"`
}

// Logs defines model for Logs.
type Logs struct {
	ChainId             *string `json:"chain_id,omitempty"`
	ChainMethod         *string `json:"chain_method,omitempty"`
	ErrorMessage        *string `json:"error_message,omitempty"`
	ErrorName           *string `json:"error_name,omitempty"`
	ErrorType           *string `json:"error_type,omitempty"`
	PortalApplicationId *string `json:"portal_application_id,omitempty"`
	Ts                  *string `json:"ts,omitempty"`
}

// Response defines model for Response.
type Response struct {
	Data *[]Response_Data_Item `json:"data,omitempty"`
}

// Response_Data_Item defines model for Response.data.Item.
type Response_Data_Item struct {
	union json.RawMessage
}

// NotFound defines model for NotFound.
type NotFound = Error

// Unauthorized defines model for Unauthorized.
type Unauthorized = Error

// GetAnalyticsRelaysAggregatedCategoryParams defines parameters for GetAnalyticsRelaysAggregatedCategory.
type GetAnalyticsRelaysAggregatedCategoryParams struct {
	From          openapi_types.Date `form:"from" json:"from"`
	To            openapi_types.Date `form:"to" json:"to"`
	CategoryValue []string           `form:"category_value" json:"category_value"`
}

// GetAnalyticsRelaysAggregatedCategoryParamsCategory defines parameters for GetAnalyticsRelaysAggregatedCategory.
type GetAnalyticsRelaysAggregatedCategoryParamsCategory string

// GetAnalyticsRelaysTotalCategoryParams defines parameters for GetAnalyticsRelaysTotalCategory.
type GetAnalyticsRelaysTotalCategoryParams struct {
	From          openapi_types.Date `form:"from" json:"from"`
	To            openapi_types.Date `form:"to" json:"to"`
	CategoryValue []string           `form:"category_value" json:"category_value"`
}

// GetAnalyticsRelaysTotalCategoryParamsCategory defines parameters for GetAnalyticsRelaysTotalCategory.
type GetAnalyticsRelaysTotalCategoryParamsCategory string

// GetAnalyticsRelaysCategoryParams defines parameters for GetAnalyticsRelaysCategory.
type GetAnalyticsRelaysCategoryParams struct {
	From                openapi_types.Date `form:"from" json:"from"`
	To                  openapi_types.Date `form:"to" json:"to"`
	AccountId           []string           `form:"account_id" json:"account_id"`
	PortalApplicationId *[]string          `form:"portal_application_id,omitempty" json:"portal_application_id,omitempty"`
	ChainId             *[]string          `form:"chain_id,omitempty" json:"chain_id,omitempty"`
	ChainMethod         *[]string          `form:"chain_method,omitempty" json:"chain_method,omitempty"`
}

// GetAnalyticsRelaysCategoryParamsCategory defines parameters for GetAnalyticsRelaysCategory.
type GetAnalyticsRelaysCategoryParamsCategory string

// GetLogsParams defines parameters for GetLogs.
type GetLogsParams struct {
	PortalApplicationId string `form:"portal_application_id" json:"portal_application_id"`

	// Page Page number (starting from 1)
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// PageSize Number of records per page
	PageSize *int `form:"page_size,omitempty" json:"page_size,omitempty"`
}

// AsAnalyticsRelaysAggregated returns the union data inside the Response_Data_Item as a AnalyticsRelaysAggregated
func (t Response_Data_Item) AsAnalyticsRelaysAggregated() (AnalyticsRelaysAggregated, error) {
	var body AnalyticsRelaysAggregated
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAnalyticsRelaysAggregated overwrites any union data inside the Response_Data_Item as the provided AnalyticsRelaysAggregated
func (t *Response_Data_Item) FromAnalyticsRelaysAggregated(v AnalyticsRelaysAggregated) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAnalyticsRelaysAggregated performs a merge with any union data inside the Response_Data_Item, using the provided AnalyticsRelaysAggregated
func (t *Response_Data_Item) MergeAnalyticsRelaysAggregated(v AnalyticsRelaysAggregated) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsAnalyticsRelaysTotal returns the union data inside the Response_Data_Item as a AnalyticsRelaysTotal
func (t Response_Data_Item) AsAnalyticsRelaysTotal() (AnalyticsRelaysTotal, error) {
	var body AnalyticsRelaysTotal
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAnalyticsRelaysTotal overwrites any union data inside the Response_Data_Item as the provided AnalyticsRelaysTotal
func (t *Response_Data_Item) FromAnalyticsRelaysTotal(v AnalyticsRelaysTotal) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAnalyticsRelaysTotal performs a merge with any union data inside the Response_Data_Item, using the provided AnalyticsRelaysTotal
func (t *Response_Data_Item) MergeAnalyticsRelaysTotal(v AnalyticsRelaysTotal) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsAnalyticsRelaysTransactions returns the union data inside the Response_Data_Item as a AnalyticsRelaysTransactions
func (t Response_Data_Item) AsAnalyticsRelaysTransactions() (AnalyticsRelaysTransactions, error) {
	var body AnalyticsRelaysTransactions
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAnalyticsRelaysTransactions overwrites any union data inside the Response_Data_Item as the provided AnalyticsRelaysTransactions
func (t *Response_Data_Item) FromAnalyticsRelaysTransactions(v AnalyticsRelaysTransactions) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAnalyticsRelaysTransactions performs a merge with any union data inside the Response_Data_Item, using the provided AnalyticsRelaysTransactions
func (t *Response_Data_Item) MergeAnalyticsRelaysTransactions(v AnalyticsRelaysTransactions) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsAnalyticsRelaysErrors returns the union data inside the Response_Data_Item as a AnalyticsRelaysErrors
func (t Response_Data_Item) AsAnalyticsRelaysErrors() (AnalyticsRelaysErrors, error) {
	var body AnalyticsRelaysErrors
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAnalyticsRelaysErrors overwrites any union data inside the Response_Data_Item as the provided AnalyticsRelaysErrors
func (t *Response_Data_Item) FromAnalyticsRelaysErrors(v AnalyticsRelaysErrors) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAnalyticsRelaysErrors performs a merge with any union data inside the Response_Data_Item, using the provided AnalyticsRelaysErrors
func (t *Response_Data_Item) MergeAnalyticsRelaysErrors(v AnalyticsRelaysErrors) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsLogs returns the union data inside the Response_Data_Item as a Logs
func (t Response_Data_Item) AsLogs() (Logs, error) {
	var body Logs
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromLogs overwrites any union data inside the Response_Data_Item as the provided Logs
func (t *Response_Data_Item) FromLogs(v Logs) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeLogs performs a merge with any union data inside the Response_Data_Item, using the provided Logs
func (t *Response_Data_Item) MergeLogs(v Logs) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t Response_Data_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Response_Data_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetAnalyticsRelaysAggregatedCategory request
	GetAnalyticsRelaysAggregatedCategory(ctx context.Context, category GetAnalyticsRelaysAggregatedCategoryParamsCategory, params *GetAnalyticsRelaysAggregatedCategoryParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAnalyticsRelaysTotalCategory request
	GetAnalyticsRelaysTotalCategory(ctx context.Context, category GetAnalyticsRelaysTotalCategoryParamsCategory, params *GetAnalyticsRelaysTotalCategoryParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAnalyticsRelaysCategory request
	GetAnalyticsRelaysCategory(ctx context.Context, category GetAnalyticsRelaysCategoryParamsCategory, params *GetAnalyticsRelaysCategoryParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetHealthcheck request
	GetHealthcheck(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLogs request
	GetLogs(ctx context.Context, params *GetLogsParams, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetAnalyticsRelaysAggregatedCategory(ctx context.Context, category GetAnalyticsRelaysAggregatedCategoryParamsCategory, params *GetAnalyticsRelaysAggregatedCategoryParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAnalyticsRelaysAggregatedCategoryRequest(c.Server, category, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAnalyticsRelaysTotalCategory(ctx context.Context, category GetAnalyticsRelaysTotalCategoryParamsCategory, params *GetAnalyticsRelaysTotalCategoryParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAnalyticsRelaysTotalCategoryRequest(c.Server, category, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAnalyticsRelaysCategory(ctx context.Context, category GetAnalyticsRelaysCategoryParamsCategory, params *GetAnalyticsRelaysCategoryParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAnalyticsRelaysCategoryRequest(c.Server, category, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetHealthcheck(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetHealthcheckRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLogs(ctx context.Context, params *GetLogsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLogsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetAnalyticsRelaysAggregatedCategoryRequest generates requests for GetAnalyticsRelaysAggregatedCategory
func NewGetAnalyticsRelaysAggregatedCategoryRequest(server string, category GetAnalyticsRelaysAggregatedCategoryParamsCategory, params *GetAnalyticsRelaysAggregatedCategoryParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "category", runtime.ParamLocationPath, category)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/analytics/relays/aggregated/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "from", runtime.ParamLocationQuery, params.From); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "to", runtime.ParamLocationQuery, params.To); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "category_value", runtime.ParamLocationQuery, params.CategoryValue); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAnalyticsRelaysTotalCategoryRequest generates requests for GetAnalyticsRelaysTotalCategory
func NewGetAnalyticsRelaysTotalCategoryRequest(server string, category GetAnalyticsRelaysTotalCategoryParamsCategory, params *GetAnalyticsRelaysTotalCategoryParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "category", runtime.ParamLocationPath, category)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/analytics/relays/total/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "from", runtime.ParamLocationQuery, params.From); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "to", runtime.ParamLocationQuery, params.To); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "category_value", runtime.ParamLocationQuery, params.CategoryValue); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAnalyticsRelaysCategoryRequest generates requests for GetAnalyticsRelaysCategory
func NewGetAnalyticsRelaysCategoryRequest(server string, category GetAnalyticsRelaysCategoryParamsCategory, params *GetAnalyticsRelaysCategoryParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "category", runtime.ParamLocationPath, category)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/analytics/relays/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "from", runtime.ParamLocationQuery, params.From); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "to", runtime.ParamLocationQuery, params.To); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "account_id", runtime.ParamLocationQuery, params.AccountId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.PortalApplicationId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "portal_application_id", runtime.ParamLocationQuery, *params.PortalApplicationId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ChainId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "chain_id", runtime.ParamLocationQuery, *params.ChainId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ChainMethod != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "chain_method", runtime.ParamLocationQuery, *params.ChainMethod); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetHealthcheckRequest generates requests for GetHealthcheck
func NewGetHealthcheckRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/healthcheck")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLogsRequest generates requests for GetLogs
func NewGetLogsRequest(server string, params *GetLogsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/logs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "portal_application_id", runtime.ParamLocationQuery, params.PortalApplicationId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page_size", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetAnalyticsRelaysAggregatedCategoryWithResponse request
	GetAnalyticsRelaysAggregatedCategoryWithResponse(ctx context.Context, category GetAnalyticsRelaysAggregatedCategoryParamsCategory, params *GetAnalyticsRelaysAggregatedCategoryParams, reqEditors ...RequestEditorFn) (*GetAnalyticsRelaysAggregatedCategoryResponse, error)

	// GetAnalyticsRelaysTotalCategoryWithResponse request
	GetAnalyticsRelaysTotalCategoryWithResponse(ctx context.Context, category GetAnalyticsRelaysTotalCategoryParamsCategory, params *GetAnalyticsRelaysTotalCategoryParams, reqEditors ...RequestEditorFn) (*GetAnalyticsRelaysTotalCategoryResponse, error)

	// GetAnalyticsRelaysCategoryWithResponse request
	GetAnalyticsRelaysCategoryWithResponse(ctx context.Context, category GetAnalyticsRelaysCategoryParamsCategory, params *GetAnalyticsRelaysCategoryParams, reqEditors ...RequestEditorFn) (*GetAnalyticsRelaysCategoryResponse, error)

	// GetHealthcheckWithResponse request
	GetHealthcheckWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetHealthcheckResponse, error)

	// GetLogsWithResponse request
	GetLogsWithResponse(ctx context.Context, params *GetLogsParams, reqEditors ...RequestEditorFn) (*GetLogsResponse, error)
}

type GetAnalyticsRelaysAggregatedCategoryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Response
	JSON204      *Error
	JSON401      *Unauthorized
	JSON404      *NotFound
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetAnalyticsRelaysAggregatedCategoryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAnalyticsRelaysAggregatedCategoryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAnalyticsRelaysTotalCategoryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Response
	JSON204      *Error
	JSON401      *Unauthorized
	JSON404      *NotFound
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetAnalyticsRelaysTotalCategoryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAnalyticsRelaysTotalCategoryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAnalyticsRelaysCategoryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Response
	JSON204      *Error
	JSON401      *Unauthorized
	JSON404      *NotFound
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetAnalyticsRelaysCategoryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAnalyticsRelaysCategoryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetHealthcheckResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetHealthcheckResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetHealthcheckResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLogsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Response
	JSON204      *Error
	JSON401      *Unauthorized
	JSON404      *NotFound
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetLogsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLogsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetAnalyticsRelaysAggregatedCategoryWithResponse request returning *GetAnalyticsRelaysAggregatedCategoryResponse
func (c *ClientWithResponses) GetAnalyticsRelaysAggregatedCategoryWithResponse(ctx context.Context, category GetAnalyticsRelaysAggregatedCategoryParamsCategory, params *GetAnalyticsRelaysAggregatedCategoryParams, reqEditors ...RequestEditorFn) (*GetAnalyticsRelaysAggregatedCategoryResponse, error) {
	rsp, err := c.GetAnalyticsRelaysAggregatedCategory(ctx, category, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAnalyticsRelaysAggregatedCategoryResponse(rsp)
}

// GetAnalyticsRelaysTotalCategoryWithResponse request returning *GetAnalyticsRelaysTotalCategoryResponse
func (c *ClientWithResponses) GetAnalyticsRelaysTotalCategoryWithResponse(ctx context.Context, category GetAnalyticsRelaysTotalCategoryParamsCategory, params *GetAnalyticsRelaysTotalCategoryParams, reqEditors ...RequestEditorFn) (*GetAnalyticsRelaysTotalCategoryResponse, error) {
	rsp, err := c.GetAnalyticsRelaysTotalCategory(ctx, category, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAnalyticsRelaysTotalCategoryResponse(rsp)
}

// GetAnalyticsRelaysCategoryWithResponse request returning *GetAnalyticsRelaysCategoryResponse
func (c *ClientWithResponses) GetAnalyticsRelaysCategoryWithResponse(ctx context.Context, category GetAnalyticsRelaysCategoryParamsCategory, params *GetAnalyticsRelaysCategoryParams, reqEditors ...RequestEditorFn) (*GetAnalyticsRelaysCategoryResponse, error) {
	rsp, err := c.GetAnalyticsRelaysCategory(ctx, category, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAnalyticsRelaysCategoryResponse(rsp)
}

// GetHealthcheckWithResponse request returning *GetHealthcheckResponse
func (c *ClientWithResponses) GetHealthcheckWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetHealthcheckResponse, error) {
	rsp, err := c.GetHealthcheck(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetHealthcheckResponse(rsp)
}

// GetLogsWithResponse request returning *GetLogsResponse
func (c *ClientWithResponses) GetLogsWithResponse(ctx context.Context, params *GetLogsParams, reqEditors ...RequestEditorFn) (*GetLogsResponse, error) {
	rsp, err := c.GetLogs(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLogsResponse(rsp)
}

// ParseGetAnalyticsRelaysAggregatedCategoryResponse parses an HTTP response from a GetAnalyticsRelaysAggregatedCategoryWithResponse call
func ParseGetAnalyticsRelaysAggregatedCategoryResponse(rsp *http.Response) (*GetAnalyticsRelaysAggregatedCategoryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAnalyticsRelaysAggregatedCategoryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 204:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON204 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAnalyticsRelaysTotalCategoryResponse parses an HTTP response from a GetAnalyticsRelaysTotalCategoryWithResponse call
func ParseGetAnalyticsRelaysTotalCategoryResponse(rsp *http.Response) (*GetAnalyticsRelaysTotalCategoryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAnalyticsRelaysTotalCategoryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 204:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON204 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAnalyticsRelaysCategoryResponse parses an HTTP response from a GetAnalyticsRelaysCategoryWithResponse call
func ParseGetAnalyticsRelaysCategoryResponse(rsp *http.Response) (*GetAnalyticsRelaysCategoryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAnalyticsRelaysCategoryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 204:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON204 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetHealthcheckResponse parses an HTTP response from a GetHealthcheckWithResponse call
func ParseGetHealthcheckResponse(rsp *http.Response) (*GetHealthcheckResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetHealthcheckResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetLogsResponse parses an HTTP response from a GetLogsWithResponse call
func ParseGetLogsResponse(rsp *http.Response) (*GetLogsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLogsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 204:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON204 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Relays analytics retrieve aggregated values of a chosen metric category between selected dates.
	// (GET /analytics/relays/aggregated/{category})
	GetAnalyticsRelaysAggregatedCategory(ctx echo.Context, category GetAnalyticsRelaysAggregatedCategoryParamsCategory, params GetAnalyticsRelaysAggregatedCategoryParams) error
	// Relays analytics retrieve aggregated values of a chosen metric category between selected dates.
	// (GET /analytics/relays/total/{category})
	GetAnalyticsRelaysTotalCategory(ctx echo.Context, category GetAnalyticsRelaysTotalCategoryParamsCategory, params GetAnalyticsRelaysTotalCategoryParams) error
	// Relays analytics retrieve aggregated values of a chosen metric category between selected dates.
	// (GET /analytics/relays/{category})
	GetAnalyticsRelaysCategory(ctx echo.Context, category GetAnalyticsRelaysCategoryParamsCategory, params GetAnalyticsRelaysCategoryParams) error
	// Check the health of the service.
	// (GET /healthcheck)
	GetHealthcheck(ctx echo.Context) error
	// Retrieve application error messages by given timestamp range.
	// (GET /logs)
	GetLogs(ctx echo.Context, params GetLogsParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// GetAnalyticsRelaysAggregatedCategory converts echo context to params.
func (w *ServerInterfaceWrapper) GetAnalyticsRelaysAggregatedCategory(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "category" -------------
	var category GetAnalyticsRelaysAggregatedCategoryParamsCategory

	err = runtime.BindStyledParameterWithLocation("simple", false, "category", runtime.ParamLocationPath, ctx.Param("category"), &category)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter category: %s", err))
	}

	ctx.Set(ApiKeyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAnalyticsRelaysAggregatedCategoryParams
	// ------------- Required query parameter "from" -------------

	err = runtime.BindQueryParameter("form", true, true, "from", ctx.QueryParams(), &params.From)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter from: %s", err))
	}

	// ------------- Required query parameter "to" -------------

	err = runtime.BindQueryParameter("form", true, true, "to", ctx.QueryParams(), &params.To)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter to: %s", err))
	}

	// ------------- Required query parameter "category_value" -------------

	err = runtime.BindQueryParameter("form", true, true, "category_value", ctx.QueryParams(), &params.CategoryValue)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter category_value: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetAnalyticsRelaysAggregatedCategory(ctx, category, params)
	return err
}

// GetAnalyticsRelaysTotalCategory converts echo context to params.
func (w *ServerInterfaceWrapper) GetAnalyticsRelaysTotalCategory(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "category" -------------
	var category GetAnalyticsRelaysTotalCategoryParamsCategory

	err = runtime.BindStyledParameterWithLocation("simple", false, "category", runtime.ParamLocationPath, ctx.Param("category"), &category)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter category: %s", err))
	}

	ctx.Set(ApiKeyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAnalyticsRelaysTotalCategoryParams
	// ------------- Required query parameter "from" -------------

	err = runtime.BindQueryParameter("form", true, true, "from", ctx.QueryParams(), &params.From)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter from: %s", err))
	}

	// ------------- Required query parameter "to" -------------

	err = runtime.BindQueryParameter("form", true, true, "to", ctx.QueryParams(), &params.To)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter to: %s", err))
	}

	// ------------- Required query parameter "category_value" -------------

	err = runtime.BindQueryParameter("form", true, true, "category_value", ctx.QueryParams(), &params.CategoryValue)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter category_value: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetAnalyticsRelaysTotalCategory(ctx, category, params)
	return err
}

// GetAnalyticsRelaysCategory converts echo context to params.
func (w *ServerInterfaceWrapper) GetAnalyticsRelaysCategory(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "category" -------------
	var category GetAnalyticsRelaysCategoryParamsCategory

	err = runtime.BindStyledParameterWithLocation("simple", false, "category", runtime.ParamLocationPath, ctx.Param("category"), &category)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter category: %s", err))
	}

	ctx.Set(ApiKeyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAnalyticsRelaysCategoryParams
	// ------------- Required query parameter "from" -------------

	err = runtime.BindQueryParameter("form", true, true, "from", ctx.QueryParams(), &params.From)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter from: %s", err))
	}

	// ------------- Required query parameter "to" -------------

	err = runtime.BindQueryParameter("form", true, true, "to", ctx.QueryParams(), &params.To)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter to: %s", err))
	}

	// ------------- Required query parameter "account_id" -------------

	err = runtime.BindQueryParameter("form", true, true, "account_id", ctx.QueryParams(), &params.AccountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account_id: %s", err))
	}

	// ------------- Optional query parameter "portal_application_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "portal_application_id", ctx.QueryParams(), &params.PortalApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter portal_application_id: %s", err))
	}

	// ------------- Optional query parameter "chain_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "chain_id", ctx.QueryParams(), &params.ChainId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter chain_id: %s", err))
	}

	// ------------- Optional query parameter "chain_method" -------------

	err = runtime.BindQueryParameter("form", true, false, "chain_method", ctx.QueryParams(), &params.ChainMethod)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter chain_method: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetAnalyticsRelaysCategory(ctx, category, params)
	return err
}

// GetHealthcheck converts echo context to params.
func (w *ServerInterfaceWrapper) GetHealthcheck(ctx echo.Context) error {
	var err error

	ctx.Set(ApiKeyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetHealthcheck(ctx)
	return err
}

// GetLogs converts echo context to params.
func (w *ServerInterfaceWrapper) GetLogs(ctx echo.Context) error {
	var err error

	ctx.Set(ApiKeyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLogsParams
	// ------------- Required query parameter "portal_application_id" -------------

	err = runtime.BindQueryParameter("form", true, true, "portal_application_id", ctx.QueryParams(), &params.PortalApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter portal_application_id: %s", err))
	}

	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", ctx.QueryParams(), &params.Page)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter page: %s", err))
	}

	// ------------- Optional query parameter "page_size" -------------

	err = runtime.BindQueryParameter("form", true, false, "page_size", ctx.QueryParams(), &params.PageSize)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter page_size: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetLogs(ctx, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/analytics/relays/aggregated/:category", wrapper.GetAnalyticsRelaysAggregatedCategory)
	router.GET(baseURL+"/analytics/relays/total/:category", wrapper.GetAnalyticsRelaysTotalCategory)
	router.GET(baseURL+"/analytics/relays/:category", wrapper.GetAnalyticsRelaysCategory)
	router.GET(baseURL+"/healthcheck", wrapper.GetHealthcheck)
	router.GET(baseURL+"/logs", wrapper.GetLogs)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/+xY32/bNhD+VwhuDxugRE7bvfgtaLO1aJEWbYc+BIFxoc4SO4lUyZMzt/D/Phwp27It",
	"JU6bdEXhN1vk/eDH7z7y+EUqW9XWoCEvx1+kQ19b4zH8Obf0p21Mxr+VNYSG+CfUdakVkLYm/eit4W9e",
	"FVgB//rV4VSO5S/p2nEaR3165px1crFYJDJDr5yu2Ykcy7fobeMUCmNJTEPMRSL/NtBQYZ3+jN8hh240",
	"4fBTg54kT2st2fGpgXJOWvm3WMLcn+a5wxwoplc7W6MjHcGDWT4pgdCoOf+dWlcBybGclhZIJpLmNcqx",
	"NE11hY5Xq4Awt24+mUHZINu0Uzw5bfIwxTaGJmQJys64NoR59JEB4Ua08CHZ9eSAcIIBir2SC/N9oxR6",
	"v4/FYvXFXn1ERexjC7ywEb4HOBWXqbN+DArQ5ubBCqmwAxMifXaRC1hMDFT9yMfh+LlneOpstRfutXUE",
	"5aRD36GlkN3D4R4wv1+y5Qeg594wPTQ97xFeB8aD4p28O5d5ExyrHTldT0hXuOdePGQNuG0NGUzjR2L9",
	"2ZIsmxugbIb9i63Qe8j7iNzn/pXNe7b32/Yhwj2cx7eK0h1Q3ywaJqInqOr9oH/b3hl28cmAwnmsCavw",
	"wRp8PZXji5uP6OFTdpHcyTJq312NuhV9R9v2TLvNKrBpcbkGE5yDeR+6fP1A1ThN83ds3MpKrV9i0G3N",
	"N5cCIUMnExmZIt+EjT969uH50Tt0M63w6LTWR2yyjhhdhHuQNtNQdpv3odZUUAEkamdnOkMveEsFF754",
	"9uG5ICuoQBEDykSWWmHLhDaX0xpUgeLR8UgmsnElp0tU+3GaXl9fH0MYPrYuT1tbn7568fTs/N3ZEdsw",
	"IprK9apC2GVqp29eyETO0PmY8km0sDUaqLUcy8fHoxC4BioCciksNyx1YcdSWLEr/bI84xY8Nccgk8zn",
	"UDwvMjmWfyENsvNpax3iOaiQkO83F+0ufWowjLXABPFMJF80teMLJLkGk84l9lYR7PdL9iG8bp3+N0VY",
	"FfuuzGyRfZtx7wsUy0DCTgWICslpxTTLkYQ2XucFeWGnxzKJefLO7qZ5Y4JomkqOL7qHcyK3VPJyF5nL",
	"ZLM7ejQa3VtTspLQnr7k9UvG7tHoycO3QOdWLAMsEvlkdDLkaQVEutGjBaMntxutGsuQwRSakr5Hf4f/",
	"1qgIM4HtnET6pqrAzUMLytUsVvogHHMPZyjWCiEC+33kpiqsR7Ok6Iq3V0jXiEZ4LGMwLjTPfCXgO8SF",
	"bDw6ecnRd9UoXJ6/TojCYXfQoIMGHTTooEHfokFfpT4/i/D8r2pA3daj7e98nw4MLH9DTe5HHfvC9DeW",
	"9xlh1Vjfv9O2If8qxwf5PcjvfctvgVBSoQpU/9wkt8870/pZuKtcvm2TtRcxyvyY4f5j9PjW+cZSx2YD",
	"paecQ2j74wSGgtbW3WX6uSes2oWW7RPa0ArDo8hep8eQ/gwr3q1C/wZyFPFlU/zmCRxpk8d3jpPfl8q+",
	"nQbkuKEjKx6fJLLSRles6ifJzuPjbvjzGNlOhUNlXeZFjU60AYZiT7z+PJTAaHRLCgcp+8mlbKlc69Bx",
	"omgfnL24motcz9CI1XuvcGBy7BOqzjtkKMvlC+TFJTOJS39ZsPGNL4Vap7MTyaOtr23Ov14KAOtsGbSV",
	"rIBaH0V3a7K3MrJbNv0utMn0TGcNlCIqheBVsK5nLFTadUHx6zBhrfsGYcVrvYcnUfACxHVhS+wUqbNZ",
	"o0guLhf/BQAA///hjdnSaB8AAA==",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
